

import asyncio
import logging
import time

from .. import loader, utils
from ..inline.types import InlineCall

from datetime import datetime
from telethon.errors import UsernameInvalidError, UsernameNotOccupiedError, FloodWaitError

logger = logging.getLogger(__name__)


@loader.tds
class DevMontiroingMod(loader.Module):
    strings_ru = {
        "name": "BOTMonitoring",
        "form_addmon": """<b>–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–æ—Ç–∞</b>

<b>ü§ñ –ë–æ—Ç:</b> <code>{bot}</code>
<b>‚è≥ –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> <code>{interval} —Å.</code>
<b>‚öôÔ∏è –ö–æ–º–∞–Ω–¥–∞:</b> <code>{command}</code>""",
        "form_bot_menu": """<b> –ë–æ—Ç {bot}</b>

<b>‚è≥ –ò–Ω—Ç–µ—Ä–≤–∞–ª:</b> <code>{interval} —Å.</code>
<b>‚öôÔ∏è –ö–æ–º–∞–Ω–¥–∞:</b> <code>{command}</code>

<b>üïî –ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞:</b> <code>{last_check}</code>
<b>üîÑ –°—Ç–∞—Ç—É—Å:</b> <code>{status}</code>""",
        "status_bot_down": "–õ–µ–∂–∏—Ç",
        "status_bot_alive": "–ñ–∏–≤–æ–π",
        "status_not_checked": "–ï—â–µ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª—Å—è",
        "action_started_monitoring": """<b>‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–æ—Ç–∞ –∑–∞–ø—É—â–µ–Ω</b>

<b>ü§ñ –ë–æ—Ç:</b> <code>{bot}</code>
<b>‚è≥ –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> <code>{interval} —Å.</code>
<b>‚öôÔ∏è –ö–æ–º–∞–Ω–¥–∞:</b> <code>{command}</code""",
        "action_bot_deleted": "<b>‚úÖ –ë–æ—Ç {bot} —É—Å–ø–µ—à–Ω–æ —Å–Ω—è—Ç —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞</b>",
        "value_not_specified": "[—É–∫–∞–∂–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ]",
        "enter_value": "‚úçÔ∏è –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —ç—Ç–æ–π –æ–ø—Ü–∏–∏",
        "msg_listmon": "–°–ø–∏—Å–æ–∫ –±–æ—Ç–æ–≤, –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥—É",
        "msg_module_disabled": "<b>–ú–æ–¥—É–ª—å –≤—ã–∫–ª—é—á–µ–Ω.</b>",
        "msg_module_enabled": "<b>–ú–æ–¥—É–ª—å –≤–∫–ª—é—á–µ–Ω</b>",
        "btn_enter_bot": "ü§ñ –ë–æ—Ç",
        "btn_enter_command": "‚öôÔ∏è –ö–æ–º–∞–Ω–¥–∞",
        "btn_enter_interval": "‚è≥ –ò–Ω—Ç–µ—Ä–≤–∞–ª",
        "btn_confirm": "‚úÖ –ó–∞–ø—É—Å—Ç–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥",
        "btn_remove_bot": "üö´ –£–¥–∞–ª–∏—Ç—å –±–æ—Ç–∞ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞",
        "err_empty": "üö´ –û–¥–Ω–æ –∏–∑ –∑–Ω–∞—á–µ–Ω–∏–π –ø—É—Å—Ç–æ–µ",
        "err_bot_exists": "<b>üö´ –ë–æ—Ç {bot} —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ</b>",
        "err_username_invalid": "<b>üö´ –Æ–∑–µ—Ä–Ω–µ–π–º–∞ {username} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç</b>",
        "err_resolving_username": "<b>üö´ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–∑–æ–ª–≤–∏–Ω–≥–µ —é–∑–µ—Ä–Ω–µ–π–º–∞</b>\n\n{err}",
        "service_bot_deleted": "üö´ –ë–æ—Ç {username} —É–¥–∞–ª–µ–Ω –∏–∑ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞. –ü—Ä–∏—á–∏–Ω–∞: –±–æ—Ç–∞ —Å —Ç–∞–∫–∏–º —é–∑–µ—Ä–Ω–µ–π–º–æ–º –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç",
        "service_bot_down": "üö´ –ë–æ—Ç {username} –ª–µ–∂–∏—Ç! (–Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –≤ —Ç–µ—á–µ–Ω–∏–µ {inverval} + 10 —Å–µ–∫—É–Ω–¥)"
    }

    strings_en = {
        "name": "DevMonitoring",
        "form_addmon": """<b>Bot monitoring</b>

<b>ü§ñ Bot:</b> <code>{bot}</code>
<b>‚è≥ Interval:</b> <code>{interval} seconds</code>
<b>‚öôÔ∏è Command:</b> <code>{command}</code>""",
        "form_bot_menu": """<b> Bot {bot}</b>

<b>‚è≥ Interval:</b> <code>{interval} seconds</code>
<b>‚öôÔ∏è Command:</b> <code>{command}</code>

<b>üïî Last check:</b> <code>{last_check}</code>
<b>üîÑ Status:</b> <code>{status}</code>""",
        "action_started_monitoring": """<b>‚úÖ Bot monitoring is started</b>

<b>ü§ñ Bot:</b> <code>{bot}</code>
<b>‚è≥ Interval:</b> <code>{interval} seconds</code>
<b>‚öôÔ∏è Command:</b> <code>{command}</code>""",
        "status_bot_down": "Down",
        "status_bot_alive": "Alive",
        "status_not_checked": "Not checked",
        "action_bot_deleted": "<b>‚úÖ Bot {bot} successfully deleted from monitoring list</b>",
        "value_not_specified": "[enter a value]",
        "enter_value": "‚úçÔ∏è Enter a new value for this option",
        "msg_listmon": "Bots in monitoring list",
        "msg_module_disabled": "<b>Module disabled.</b>",
        "msg_module_enabled": "<b>Module enabled</b>",
        "btn_enter_bot": "ü§ñ Bot",
        "btn_enter_command": "‚öôÔ∏è Command",
        "btn_enter_interval": "‚è≥ Interval",
        "btn_confirm": "‚úÖ Start monitoring",
        "btn_remove_bot": "üö´ Remove bot from monitoring",
        "err_empty": "üö´ One of the values is empty or invalid",
        "err_bot_exists": "<b>üö´ Bot {bot} already exists in monitoring list</b>",
        "err_username_invalid": "<b>üö´ Username {username} is invalid</b>",
        "err_resolving_username": "<b>üö´ An unknown error occurred while resolving username</b>\n\n{err}",
        "service_bot_deleted": "üö´ Bot {username} deleted from the monitoring list. Reason: invalid username",
        "service_bot_down": "üö´ Bot {username} is down! (the bot did not respond within {interval} + 10 seconds)"
    }

    async def client_ready(self):
        self.bots: list = self.pointer("bots", [])
        
        if self.get("enabled") is None:
            self.set("enabled", True)
    
    async def get_bot_entity(self, bot_username):
        bot_username = bot_username.replace("@", "").replace("https://t.me/", "").lower()
        
        try:
            entity = await self.client.get_entity(bot_username)
        except FloodWaitError:
            async for d in self.client.iter_dialogs():
                if getattr(d.entity, "username", None) is not None:
                    if d.entity.username.lower() == bot_username:
                        entity = d.entity
                        break
        
        return entity
    
    def update_bot(self, bot_username, key, value):
        for bot_obj in self.bots:
            if bot_obj["bot"] == bot_username:
                bot_obj[key] = value
    
    async def remove_bot(self, call, bot_username: str):
        for bot_obj in self.bots:
            if bot_obj["bot"] == bot_username:
                self.bots.remove(bot_obj)
                break
        
        await call.edit(
            text=self.strings("action_bot_deleted").format(
                bot=bot_username
            )
        )

    async def confirm(self, call, args: dict):
        if None in args.values():
            return await call.answer(
                self.strings("err_empty"),
                show_alert=True
            )
        
        for bot_obj in self.bots:
            if bot_obj["bot"] == args["bot"]:
                return await call.edit(
                    text=self.strings("err_bot_exists").format(
                        bot=args["bot"]
                    )
                )

        await call.edit(
            text=self.strings("action_started_monitoring").format(
                bot=args.get("bot"),
                interval=args.get("interval"),
                command=args.get("command")
            ),
            reply_markup={
                "text": self.strings("btn_remove_bot"),
                "callback": self.remove_bot,
                "args": [args["bot"]]
            }
        )

        self.bots.append(args)

    async def update_value(self, call: InlineCall, option: str, param: str, args: dict):
        args[param] = option
        
        if param == "interval":
            if not option.isdigit():
                args[param] = 60
            else:
                args[param] = int(option)
        
        if param == "bot":
            try:
                entity = await self.get_bot_entity(option)
            except (UsernameInvalidError, UsernameNotOccupiedError):
                return await call.edit(
                    text=self.strings("err_username_invalid").format(
                        username=option
                    )
                )
            except Exception as error:
                return await call.edit(
                    text=self.strings("err_resolving_username").format(
                        err=error
                    )
                )
            else:
                option = "@" + entity.username
                args[param] = option

        await call.edit(
            text=self.strings("form_addmon").format(
                bot=args.get("bot") or self.strings("value_not_specified"),
                interval=args.get("interval") or self.strings("value_not_specified"),
                command=args.get("command") or self.strings("value_not_specified")
            ),
            disable_security=True,
            reply_markup=[
                [
                    {
                        "text": self.strings("btn_enter_bot"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "bot"}
                    }
                ],
                [
                    {
                        "text": self.strings("btn_enter_interval"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "interval"}
                    },
                    {
                        "text": self.strings("btn_enter_command"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "command"}
                    }
                ],
                [
                    {
                        "text": self.strings("btn_confirm"),
                        "callback": self.confirm,
                        "args": [args]
                    }
                ]
            ]
        )

    async def bot_menu(self, call: InlineCall, bot_obj: dict):
        statuses = {
            None: self.strings("status_bot_not_checked"),
            True: self.strings("status_bot_alive"),
            False: self.strings("status_bot_down")
        }
        
        status = statuses[bot_obj.get("alive")]
        last_check = "Not checked"
        
        if bot_obj.get("last_check") is not None:
            last_check = datetime.fromtimestamp(bot_obj["last_check"]).strftime("%d.%m %H:%M")
        
        await call.edit(
            text=self.strings("form_bot_menu").format(
                interval=bot_obj["interval"],
                command=bot_obj["command"],
                bot=bot_obj["bot"],
                last_check=last_check,
                status=status
            ),
            reply_markup={
                "text": self.strings("btn_remove_bot"),
                "callback": self.remove_bot,
                "args": [bot_obj["bot"]]
            }
        )

    @loader.command(
        ru_doc="–ü–æ—Å—Ç–∞–≤–∏—Ç—å –±–æ—Ç–∞ –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥",
        en_doc="Add bot to monitoring"
    )
    async def addmon(self, message):
        args = {
            "bot": None,
            "interval": 60,
            "command": "/start"
        }

        await self.inline.form(
            text=self.strings("form_addmon").format(
                bot=args.get("bot") or self.strings("value_not_specified"),
                interval=args.get("interval") or self.strings("value_not_specified"),
                command=args.get("command") or self.strings("value_not_specified")
            ),
            message=message,
            disable_security=True,
            reply_markup=[
                [
                    {
                        "text": self.strings("btn_enter_bot"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "bot"}
                    }
                ],
                [
                    {
                        "text": self.strings("btn_enter_interval"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "interval"}
                    },
                    {
                        "text": self.strings("btn_enter_command"),
                        "input": self.strings("enter_value"),
                        "handler": self.update_value,
                        "kwargs": {"args": args, "param": "command"}
                    }
                ],
                [
                    {
                        "text": self.strings("btn_confirm"),
                        "callback": self.confirm,
                        "args": [args]
                    }
                ]
            ]
        )

    @loader.command(
        ru_doc="–í—ã–∫–ª—é—á–∏—Ç—å/–≤–∫–ª—é—á–∏—Ç—å –º–æ–¥—É–ª—å",
        en_doc="Disable/enable module"
    )
    async def togglemon(self, message):
        enabled = self.get("enabled")
        enabled = not enabled
        self.set("enabled", enabled)
        
        if enabled:
            await utils.answer(
                message=message,
                response=self.strings("msg_module_enabled")
            )
        
        else:
            await utils.answer(
                message=message,
                response=self.strings("msg_module_disabled")
            )
    
    @loader.command(
        ru_doc="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏",
        en_doc="Manage bots"
    )
    async def listmon(self, message):
        reply_markup = []
        
        statuses = {
            None: "‚ö™Ô∏è",
            True: "üü¢",
            False: "üî¥"
        }
        
        for bot_obj in self.bots:
            status = statuses[bot_obj.get("alive")]
            bot = bot_obj["bot"]
            last_check = ""
            
            if bot_obj.get("last_check") is not None:
                last_check = datetime.fromtimestamp(bot_obj["last_check"]).strftime("%d.%m %H:%M")
            
            reply_markup.append([
                {
                    "text": f"{status} {last_check} {bot}",
                    "args": [bot_obj],
                    "callback": self.bot_menu
                }
            ])
        
        await self.inline.form(
            text=self.strings("msg_listmon"),
            message=message,
            reply_markup=reply_markup
        )
    
    async def _check_bot_conv(self, bot_obj):        
        async with self.client.conversation(bot_obj["bot"]) as conv:
            message = await conv.send_message(bot_obj["command"])
            
            try:
                response = await conv.get_response(timeout=10)
            except asyncio.TimeoutError:
                await self.inline.bot.send_message(
                    self.tg_id,
                    self.strings("service_bot_down").format(
                        username=bot_obj["bot"],
                        interval=bot_obj["interval"]
                    )
                )
                
                self.update_bot(bot_obj["bot"], "alive", False)
            else:
                await conv.mark_read()
                await message.delete()
                await response.delete()
                
                self.update_bot(bot_obj["bot"], "alive", True)
            
            self.update_bot(bot_obj["bot"], "last_check", time.time())
    
    async def _check_interval(self, bot_obj):
        if not time.time() > bot_obj.get("last_check", 0) + bot_obj.get("interval"):
            return

        try:
            await self._check_bot_conv(bot_obj)
        except (UsernameInvalidError, UsernameNotOccupiedError):
            await self.inline.bot.send_message(
                self.tg_id,
                self.strings("service_bot_deleted").format(
                    username=bot_obj["bot"]
                )
            )

            self.bots.remove(bot_obj)

    @loader.loop(interval=1, autostart=True)
    async def check_bots(self):
        if not self.get("enabled"):
            return

        await asyncio.gather(*[
            self._check_interval(bot_obj)
            for bot_obj in self.bots
        ])